コピペ用(スキル効果=>実装コード)

<錬成武器判定>
if (targetUnit.isWeaponRefined) {}
<特殊錬成武器判定>
if (targetUnit.isWeaponSpecialRefined) {}

武器錬成テンプレ
if (!targetUnit.isWeaponRefined) {
    // <通常効果>
} else {
    // <錬成効果>
    if (targetUnit.isWeaponSpecialRefined) {
        // <特殊錬成効果>
    }
}

武器錬成テンプレ(錬成効果追加のみ)
if (targetUnit.isWeaponRefined) {
    // <錬成効果>
    if (targetUnit.isWeaponSpecialRefined) {
        // <特殊錬成効果>
    }
}

ステータスアップ
updateStatusBySkillsAndMerges(updatesPureGrowthRate = true, syncBlessingEffects = true, isPairUpBoostsEnabled = false) {
    // 錬成していれば攻撃+3
    if (this.isWeaponRefined) {
        this.atkWithSkills += 3;
    }
}

化身状態なら
if (targetUnit.isTransformed) {}

ターン開始時
applySkillForBeginningOfTurnFuncMap.set(skillId,
    function (skillOwner) {
    }
);
敵軍ターン開始時
applyEnemySkillForBeginningOfTurnFuncMap.set(skillId,
    function (skillOwner) {
    }
);
もしくは
ターン開始時(通常)
applySkillForBeginningOfTurn(skillId, skillOwner) {}
ターン開始時(回復)
applyHealSkillForBeginningOfTurn(skillId, skillOwner) {}
敵ターン開始時[敵軍ターン開始時]
applyEnemySkillForBeginningOfTurn(skillId, skillOwner) {}
ターン開始時(ダメージ)
applyDamageSkillForBeginningOfTurn(skillId, skillOwner) {}
敵軍のターン開始時スキル発動後
applyAfterEnemySkillsSkillForBeginningOfTurn(skillId, skillOwner) {}

獣の共通の化身スキル
WeaponTypesAddAtk2AfterTransform[skillId] = 0;
BeastCommonSkillMap.set(skillId, BeastCommonSkillType.Cavalry2);
もしくは
const WeaponTypesAddAtk2AfterTransform = {};
WeaponTypesAddAtk2AfterTransform[Weapon.XXX] = 0;
const BeastCommonSkillMap =
    new Map([
            [Weapon.XXX, BeastCommonSkillType.YYY], // 歩行、騎馬を実装済み

敵が赤属性の時
if (enemyUnit.color === ColorType.Red)

[相性計算]
static calcAttackerTriangleAdvantage(atkUnit, defUnit) {}

無属性の敵と戦闘時、自分は3すくみ有利、敵は3すくみ不利となる[レイヴン]
targetUnit.battleContext.isAdvantageForColorless = true; 

3すくみ有利だと、さらに攻撃+20%[相性激化]
getTriangleAdeptAdditionalRatio() {
    if (isTriangleAdeptSkill(this.passiveA)
        || isTriangleAdeptSkill(this.weapon)
        || (this.weapon === Weapon.Forukuvangu && this.isWeaponSpecialRefined)
        || (this.weapon === Weapon.TomeOfOrder && this.isWeaponSpecialRefined)
        || this.hasStatusEffect(StatusEffectType.TriangleAdept)
    ) {
        return 0.2;
    }
}

3すくみ有利の時
if (DamageCalculationUtility.calcAttackerTriangleAdvantage(targetUnit, enemyUnit) === TriangleAdvantage.Advantageous) {}

特効を受ける
const EffectiveFuncTable = {};
EffectiveFuncTable[EffectiveType.XXX] = unit => { ... };

特効を受ける
atkUnit.battleContext.isEffectiveToOpponent = true

特効
__setEffectiveAttackEnabledIfPossible(atkUnit, defUnit) {
    if (DamageCalculationUtility.isEffectiveAttackEnabled(defUnit, EffectiveType.XXX)) {
        atkUnit.battleContext.isEffectiveToOpponent = true;
        return;
    }
}

敵が歩行、飛行、騎馬、重装の時
if (enemyUnit.moveType === MoveType.Infantry) {}
if (enemyUnit.moveType === MoveType.Flying) {}
if (enemyUnit.moveType === MoveType.Cavalry) {}
if (enemyUnit.moveType === MoveType.Armor:) {}

射程
1距離
isMeleeWeaponType(weaponType)
2距離
isRangedWeaponType(weaponType)

防御地形の効果を無効
atkUnit.battleContext.invalidatesDefensiveTerrainEffect = true;

自分から攻撃した時
if (targetUnit.battleContext.initiatesCombat) {
敵から攻撃された時
if (enemyUnit.battleContext.initiatesCombat) {

周囲2マス以内に味方がいる時
if (__isThereAllyIn2Spaces(targetUnit)) {}

周囲Nマス以内に味方がいる時
if (this.__isThereAllyInSpecifiedSpaces(targetUnit, N)) {}

周囲1マス以内に味方がいない時(孤軍)
if (this.__isSolo(targetUnit) || calcPotentialDamage) {}

周囲Nマス以内にいる、最も近い敵
for (let unit of this.__findNearestEnemies(<unit>, <N>)) {}

周囲からのバフ[周囲XXの味方は, YY以内の味方は]
updateUnitSpurFromAlliesFuncMap.set(skillId,
    function (targetUnit, allyUnit, calcPotentialDamage, enemyUnit) {
        // 周囲2マス以内
        if (targetUnit.distance(allyUnit) <= 2) {
        }
        // 5×3マス以内にいる場合
        if (Math.abs(allyUnit.posX - targetUnit.posX) <= 1 &&
            Math.abs(allyUnit.posY - targetUnit.posY) <= 2) {
            if (!allyUnit.isWeaponRefined) {
                targetUnit.addAtkResSpurs(3);
            } else {
                targetUnit.addAtkResSpurs(4);
            }
        }
    }
);

周囲からのスキル効果(バフ以外)[周囲XXの味方は, YY以内の味方は]
applySkillEffectFromAlliesFuncMap.set(skillId,
    function (targetUnit, enemyUnit, allyUnit, calcPotentialDamage) {
    }
);

周囲の敵からのデバフ効果(牽制など)[周囲2マスの敵は、戦闘中...]
updateUnitSpurFromEnemyAlliesFuncMap.set(skillId,
    function (targetUnit, enemyUnit, enemyAllyUnit, calcPotentialDamage) {
        // enemyAllyUnitからのスキルなので錬成判定に注意
        if (!enemyAllyUnit.isWeaponRefined) {
            // <通常効果>
            if (targetUnit.distance(enemyAllyUnit) <= 2) {
                targetUnit.addAtkResSpurs(-6);
            }
        } else {
            // <錬成効果>
            if (enemyAllyUnit.isWeaponSpecialRefined) {
                // <特殊錬成効果>
            }
        }
    }
);

周囲の敵からのスキル効果[周囲2マスの敵は、戦闘中...]
applySkillEffectFromEnemyAlliesFuncMap.set(skillId,
    function (targetUnit, enemyUnit, enemyAllyUnit, calcPotentialDamage) {
        if (targetUnit.isInCrossWithOffset(enemyAllyUnit, 1)) {
            targetUnit.battleContext.followupAttackPriorityIncrement++;
        }
    }
);

暗闘
__applyPreUpdateUnitSpurSkillEffects(targetUnit, enemyUnit, calcPotentialDamage) {
    // 赤への暗闘
    if (enemyUnit.color === ColorType.Red) {
        targetUnit.battleContext.disablesSkillsFromEnemyAlliesInCombat = true;
    }
    targetUnit.battleContext.disablesSkillsFromRedEnemyAlliesInCombat = true;
}

[暗闘の対象外になる周囲からのスキル効果]
applySkillEffectFromAlliesExcludedFromFeudFuncMap.set(skillId,
    function (targetUnit, enemyUnit, allyUnit, calcPotentialDamage) {
    }
);
もしくは
__applySkillEffectFromAlliesExcludedFromFeud(targetUnit, enemyUnit, calcPotentialDamage) {}

戦闘開始時、自身(敵)のHPがN%以上なら
targetUnit.battleContext.restHpPercentage >= N
enemyUnit.battleContext.restHpPercentage >= N

ターン開始時、自身のHPがN%以上なら
skillOwner.restHpPercentageAtBeginningOfTurn >= N

速さの差を比較するスキルの比較判定時、自身の速さ+Nとして判定[虚勢]
evalSpdAddFuncMap.set(skillId, function (unit) {
    return 7;
})
もしくは
const EvalSpdAddDict = {};
EvalSpdAddDict[<skill id>] = N;

速さが敵よりN以上高い時
__applySkillEffectForUnitAfterCombatStatusFixed() {
    if (targetUnit.getEvalSpdInCombat() >= enemyUnit.getEvalSpdInCombat() + N) {
    }
}

2回攻撃
targetUnit.battleContext.setAttackCountFuncs.push(
    (targetUnit, enemyUnit) => {
        // 攻撃時
        targetUnit.battleContext.attackCount = 2;
        // 攻撃を受けた時
        targetUnit.battleContext.counterattackCount = 2;
    }
);
もしくは
__setAttackCount(targetUnit, enemyUnit) {
    // 攻撃時
    targetUnit.battleContext.attackCount = 2;
    // 攻撃を受けた時
    targetUnit.battleContext.counterattackCount = 2;
}

追撃可能なら自分の攻撃の直後に追撃を行う(攻め立て)
__applyChangingAttackPrioritySkillEffects(atkUnit, defUnit) {
    atkUnit.battleContext.isDesperationActivatable = true;
}

敵が追撃可能なら、最初に受けた攻撃のダメージをN%軽減
__setBothOfAtkDefSkillEffetToContext(targetUnit, enemyUnit) {
    if (enemyUnit.battleContext.canFollowupAttack) {
        targetUnit.battleContext.multDamageReductionRatioOfFirstAttack(N / 100.0, enemyUnit);
    }
}

[追撃可能の判定に関するスキル効果]
applySkillEffectRelatedToFollowupAttackPossibilityFuncMap.set(skillId,
    function (targetUnit, enemyUnit) {
    }
);

敵から攻撃された時、先制攻撃[待ち伏せ]
targetUnit.battleContext.isVantageActivatable = true;

自身の戦闘順入替スキル(待ち伏せ、攻め立て等)無効、敵の戦闘順入替スキル(待ち伏せ、攻め立て等)無効[不動の姿勢]
canDisableAttackOrderSwapSkill(restHpPercentage) {
    return true;
}

絶対追撃
targetUnit.battleContext.followupAttackPriorityIncrement++;

敵は追撃不可
enemyUnit.battleContext.followupAttackPriorityDecrement--;

敵の絶対追撃を無効
targetUnit.battleContext.invalidatesAbsoluteFollowupAttack = true;

自身の追撃不可を無効
targetUnit.battleContext.invalidatesInvalidationOfFollowupAttack = true;

敵の追撃の速さ条件+20(targetUnitから見て)
enemyUnit.battleContext.additionalSpdDifferenceNecessaryForFollowupAttack += 20;

[神速追撃]
applySkillEffectRelatedToFollowupAttackPossibilityFuncMap.set(skillId,
    function (targetUnit, enemyUnit) {
        this.__applyPotent(targetUnit, enemyUnit);
    }
);

反撃不可
targetUnit.battleContext.invalidatesCounterattack = true;
もしくは
static __canDisableCounterAttack(atkUnit, defUnit) {
    return true;
}

全距離反撃
targetUnit.battleContext.canCounterattackToAllDistance = true;

戦闘中、自分が受けている反撃不可を無効
__canDisableCounterAttack(atkUnit, defUnit) {
    return false;
}
もしくは
targetUnit.battleContext.nullCounterDisrupt = true;

敵が反撃可能なら
this.canCounterAttack(atkUnit, defUnit)

自分が受けている攻撃、速さ、守備、魔防の強化の値だけ上昇(強化増幅)
__applySkillEffectForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    DamageCalculatorWrapper.__applyBonusDoubler(targetUnit, enemyUnit);
}
[部分強化増幅]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    targetUnit.atkSpur += targetUnit.getAtkBuffInCombat(enemyUnit);
}

攻撃、速さ、守備、魔防が強化が<units>の最も高い値だけ増加(能力値ごとに計算)[味方強化増幅]
targetUnit.battleContext.applySpurForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        // 周囲3マス以内の場合
        let units = this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(targetUnit, 3);
        let amounts = this.__getHighestBuffs(targetUnit, enemyUnit, units, true); // 自分を含む場合はtrueを指定
        targetUnit.addSpurs(...amounts);
    }
);

敵の強化の+を無効(強化無効)
targetUnit.battleContext.invalidateAllBuffs();
targetUnit.battleContext.invalidatesAtkBuff = true;
targetUnit.battleContext.invalidateBuffs(true, true, true, true);

敵が強化を受けていれば、戦闘中、自身の攻撃、速さ、守備、魔防が敵が受けている強化の値だけ上昇し、敵の攻撃、速さ、守備、魔防が敵が受けている強化の値だけ減少(能力値ごとに計算)[強化吸収]
targetUnit.battleContext.applySpurForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        this.__applyBuffAbsorption(targetUnit, enemyUnit);
        // 攻撃、速さ、魔防だけ吸収
        // this.__applyBuffAbsorption(targetUnit, enemyUnit, 1, 1, 0, 1);
    }
);
もしくは
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    this.__applyBuffAbsorption(targetUnit, enemyUnit);
    // 攻撃、速さ、魔防だけ吸収
    // this.__applyBuffAbsorption(targetUnit, enemyUnit, 1, 1, 0, 1);
}

自身の弱化を無効(弱化無効)
targetUnit.battleContext.invalidateAllOwnDebuffs();
targetUnit.battleContext.invalidatesOwnAtkDebuff = true;

自分が弱化を受けていれば、能力値が弱化の値の2倍だけ上昇(能力値ごとに計算)(例えば、攻撃-7の弱化を受けていれば、-7+14+4で、戦闘中、攻撃+11となる)[弱化反転]
targetUnit.battleContext.applySpurForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        this.__applyDebuffReverse(targetUnit, "スキルorステータス名");
        // 武器スキルの場合
        // this.__applyDebuffReverse(targetUnit, targetUnit.weaponInfo.name);
    }
);
もしくは
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    this.__applyDebuffReverse(targetUnit, "スキルorステータス名");
}

弱化を受けていれば、戦闘中、敵の弱化の値だけ減少(能力値ごとに計算)(例えば、攻撃-7の弱化を受けていれば、-7-7で、戦闘中、攻撃-14となる)[弱化増幅]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    enemyUnit.atkSpur -= Math.abs(enemyUnit.atkDebuffTotal);
    enemyUnit.spdSpur -= Math.abs(enemyUnit.spdDebuffTotal);
    enemyUnit.defSpur -= Math.abs(enemyUnit.defDebuffTotal);
    enemyUnit.resSpur -= Math.abs(enemyUnit.resDebuffTotal);
}

強化の値の2倍だけ減少[強化反転]
// targetUnitが相手に対して効果を発動する場合enemyUnitを指定
// 一括
enemyUnit.battleContext.setAllBonusReversal();
// 個別一括
enemyUnit.battleContext.setBonusReversals(true, true, true, true);
// 攻撃だけ
enemyUnit.battleContext.isAtkBonusReversal = false;
もしくは
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    enemyUnit.atkSpur -= Math.max(enemyUnit.getAtkBuffInCombat(targetUnit), 0) * 2;
    enemyUnit.spdSpur -= Math.max(enemyUnit.getSpdBuffInCombat(targetUnit), 0) * 2;
    enemyUnit.defSpur -= Math.max(enemyUnit.getDefBuffInCombat(targetUnit), 0) * 2;
    enemyUnit.resSpur -= Math.max(enemyUnit.getResBuffInCombat(targetUnit), 0) * 2;
}

敵の攻撃、速さ、守備、魔防が、敵が受けている強化の値だけ減少(能力値ごとに計算)[強化打ち消し]
targetUnit.battleContext.applySpurForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        enemyUnit.atkSpur -= Math.max(enemyUnit.getAtkBuffInCombat(targetUnit, 0));
        enemyUnit.spdSpur -= Math.max(enemyUnit.getSpdBuffInCombat(targetUnit, 0));
        enemyUnit.defSpur -= Math.max(enemyUnit.getDefBuffInCombat(targetUnit, 0));
        enemyUnit.resSpur -= Math.max(enemyUnit.getResBuffInCombat(targetUnit, 0));
    }
);

敵が受けている強化の合計値を攻撃に加算[敵ブレード]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    targetUnit.atkSpur += Math.max(enemyUnit.getBuffTotalInCombat(targetUnit), 0);
}

敵が受けている弱化の合計値を自分の攻撃に加算[弱化ブレード]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    DamageCalculationUtility.applyDebuffBlade(targetUnit, enemyUnit);
}

戦闘中、周囲2マス以内にいる味方のうち、強化の合計値が最も高い味方の強化の合計値を攻撃に加算(例えば、周囲2マス以内の味方が攻撃、速さ、守備、魔防+6の強化を受けていれば、24を攻撃に加算)[アスタルテブレード、味方ブレード]
__applySpurForUnitAfterCombatStatusFixed
    let maxBuff = 0;
    for (let unit of this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(targetUnit, 2, false)) {
        maxBuff = Math.max(unit.buffTotal, maxBuff);
    }
    targetUnit.atkSpur += maxBuff;
}

自分と周囲3マス以内にいる味方のうち、強化の合計値が最も高い値
targetUnit.battleContext.applySpurForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        // 周囲3マス以内の場合
        let units = this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(targetUnit, 3);
        let buffTotal = this.__getHighestTotalBuff(targetUnit, enemyUnit, units, true); // 自分を含む場合はtrueを指定
    }
);

敵が強化を受けていれば、戦闘中、自身の攻撃、速さ、守備、魔防が敵が受けている強化の値だけ上昇(能力値ごとに計算)[敵強化増幅]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    targetUnit.atkSpur += enemyUnit.getAtkBuffInCombat(targetUnit);
    targetUnit.spdSpur += enemyUnit.getSpdBuffInCombat(targetUnit);
    targetUnit.defSpur += enemyUnit.getDefBuffInCombat(targetUnit);
    targetUnit.resSpur += enemyUnit.getResBuffInCombat(targetUnit);
}

敵の攻撃、速さ、守備、魔防が敵が受けている強化の値だけ減少(能力値ごとに計算)[敵強化減少]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    enemyUnit.atkSpur -= enemyUnit.getAtkBuffInCombat(targetUnit);
    enemyUnit.spdSpur -= enemyUnit.getSpdBuffInCombat(targetUnit);
    enemyUnit.defSpur -= enemyUnit.getDefBuffInCombat(targetUnit);
    enemyUnit.resSpur -= enemyUnit.getResBuffInCombat(targetUnit);
}

戦闘相手の弱化の合計値と、その周囲2マス以内の敵の弱化の合計値のうち、最も高い値
let debuffTotal = enemyUnit.debuffTotal;
for (let unit of this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(enemyUnit, 2)) {
    debuffTotal = Math.min(debuffTotal, unit.getDebuffTotal(true));
}

敵とその周囲2マス以内にいる敵のうち弱化が最も高い値(能力値ごとに計算)
targetUnit.battleContext.applySpurForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        let debuffs = this.__maxDebuffsFromAlliesWithinSpecificSpaces(enemyUnit, 2, true);
        enemyUnit.addSpurs(...debuffs);
    }
);

ステータス決定後のバフ効果
targetUnit.battleContext.applySpurForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
    }
);

ステータス決定後のスキル効果
targetUnit.battleContext.applySkillEffectForUnitForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
    }
);

敵が[有利/不利]な状態異常を受けている時
targetUnit.battleContext.applySkillEffectRelatedToEnemyStatusEffectsFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
    }
);
もしくは
__applySkillEffectRelatedToEnemyStatusEffects(targetUnit, enemyUnit, calcPotentialDamage) {
   if (enemyUnit.hasPositiveStatusEffect(targetUnit)) {}
   if (enemyUnit.hasNegativeStatusEffect()) {}
}

HP N回復
targetUnit.reserveHeal(N);

ターン開始時HP回復
applyHealSkillForBeginningOfTurnFuncMap.set(skillId,
    function (skillOwner) {
        // 周囲2マスと自分
        for (let unit of this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(skillOwner, 2, true)) {
            unit.reserveHeal(20);
        }
    }
);

自分の攻撃でダメージを与えた時、自分のHP N回復(与えたダメージが0でも効果は発動)
targetUnit.battleContext.healedHpByAttack += N

自分の追撃でダメージを与えた時、N回復(与えたダメージが0でも効果は発動)
targetUnit.battleContext.healedHpByFollowupAttack += N;

戦闘後
// こちらはthisをPostCombatSkillHandlerにしたい場合に使用する
applySkillEffectAfterCombatForUnitFuncMap.set(skillId,
    function(targetUnit, enemyUnit) {
    }
);
もしくは
targetUnit.battleContext.applySkillEffectAfterCombatForUnitFuncs.push(
    (targetUnit, enemyUnit) => {
    }
);

戦闘後（その戦闘で自分のHPが0になっても発動）
applySkillEffectAfterCombatNeverthelessDeadForUnitFuncMap.set(skillId,
    function (attackUnit, attackTargetUnit, attackCount) {
    }
);

戦闘後、HP N回復/Nダメージ
targetUnit.battleContext.healedHpAfterCombat += N;
または
__applySkillEffectAfterCombatForUnit() {
  targetUnit.reserveHeal(N);
  targetUnit.reserveTakeDamage(N);
}

戦闘開始後スキル
applySKillEffectForUnitAtBeginningOfCombatFuncMap.set(skillId,
    function (targetUnit, enemyUnit, calcPotentialDamage) {
    }
);

戦闘開始後、敵に7ダメージ(戦闘中にダメージを減らす効果の対象外、ダメージ後のHPは最低1)
__applySKillEffectForUnitAtBeginningOfCombat(targetUnit, enemyUnit, calcPotentialDamage) {
    enemyUnit.restHp -= 7;
    if (enemyUnit.restHp <= 0) {
        enemyUnit.restHp = 1;
    }
}

周囲Nマスの味方は戦闘後、7回復(暗闘の対象にならないスキル効果)
applySkillEffectFromAlliesExcludedFromFeudFuncMap.set(skillId,
    function (targetUnit, enemyUnit, allyUnit, calcPotentialDamage) {
        if (targetUnit.distance(allyUnit) <= N) {
            targetUnit.battleContext.healedHpAfterCombat += 7;
        }
    }
);
もしくは
__applySkillEffectFromAlliesExcludedFromFeud(targetUnit, enemyUnit, calcPotentialDamage) {
  targetUnit.battleContext.healedHpAfterCombat += 7;
}

奥義実装テンプレ
{
    let skillId = Special.SSS;
    // 通常攻撃奥義(範囲奥義・疾風迅雷などは除く)
    // NormalAttackSpecialDict[skillId] = 0;
    // 守備奥義
    // DefenseSpecialDict[skillId] = 0;

    // 奥義カウント設定(ダメージ計算機で使用。奥義カウント2-4の奥義を設定)
    // countNSpecials.push(skillId);
    // inheritableCountNSpecials.push(skillId);

    initApplySpecialSkillEffectFuncMap.set(skillId,
        function (targetUnit, enemyUnit) {
            // 緋炎
            let status = targetUnit.getXInCombat(enemyUnit);
            targetUnit.battleContext.specialAddDamage = Math.trunc(status * 0.5);
            // 黒の月光
            targetUnit.battleContext.specialSufferPercentage = 80;
        }
    );

    // 奥義によるダメージ軽減
    applyDamageReductionRatioBySpecialFuncMap.set(skillId,
        function (defUnit, atkUnit, attackRange) {
            // 40%軽減
            defUnit.battleContext.damageReductionRatioBySpecial = 0.4;
        }
    );

    // 奥義発動後、自分の次の攻撃のスキル効果を発動
    activatesNextAttackSkillEffectAfterSpecialActivatedFuncMap.set(skillId,
        function (defUnit, atkUnit) {
            // 2距離の場合
            if (atkUnit.getActualAttackRange(defUnit) === 2) {
                defUnit.battleContext.nextAttackEffectAfterSpecialActivated = true;
            }
        }
    );

    // 攻撃を受けた時に発動する奥義発動後の攻撃のダメージ加算
    addSpecialDamageAfterDefenderSpecialActivatedFuncMap.set(skillId,
        function (atkUnit, defUnit) {
            // 自分の攻撃の40%
            if (atkUnit.battleContext.nextAttackEffectAfterSpecialActivated) {
                atkUnit.battleContext.nextAttackEffectAfterSpecialActivated = false;
                return floorNumberWithFloatError(atkUnit.getAtkInCombat(defUnit) * 0.4);
            }
            return 0;
        }
    );

    // 奥義発動後のスキル効果
    // 奥義を発動したユニットがtargetUnit
    applySkillEffectAfterSpecialActivatedFuncMap.set(skillId,
        function (targetUnit, enemyUnit, context) {
            // 反竜穿・承
            if (targetUnit.battleContext.specialActivatedCount === 1) {
                let isAttackTwice =
                    (targetUnit.battleContext.initiatesCombat && enemyUnit.battleContext.counterattackCount === 2) ||
                    (enemyUnit.battleContext.initiatesCombat && enemyUnit.battleContext.attackCount === 2);
                if (isAttackTwice) {
                    this.writeDebugLog(`${targetUnit.nameWithGroup}の奥義発動直後の奥義カウントが${targetUnit.tmpSpecialCount}から2減少`);
                    this.__reduceSpecialCount(targetUnit, 2);
                }
            }
        }
    );

    // 攻撃奥義のダメージ軽減
    applyDamageReductionRatiosWhenCondSatisfiedFuncMap.set(skillId,
        function (atkUnit, defUnit) {
            if (defUnit.tmpSpecialCount === 0 ||
                atkUnit.tmpSpecialCount === 0 ||
                defUnit.battleContext.isSpecialActivated ||
                atkUnit.battleContext.isSpecialActivated) {
                // 敵が1距離の時40%軽減
                if (isMeleeWeaponType(atkUnit.weaponType)) {
                    defUnit.battleContext.damageReductionRatiosWhenCondSatisfied.push(0.4);
                }
            }
        }
    );

    // 範囲奥義
    RangedAttackSpecialDict[skillId] = 0;
    RangedAttackSpecialDamageRateDict[skillId] = 1;

    // 十字範囲
    enumerateRangedSpecialTilesFuncMap.set(skillId,
        function* (targetTile) {
            yield targetTile;
            yield this.getTile(targetTile.posX - 1, targetTile.posY);
            yield this.getTile(targetTile.posX + 1, targetTile.posY);
            yield this.getTile(targetTile.posX, targetTile.posY - 1);
            yield this.getTile(targetTile.posX, targetTile.posY + 1);
        }
    );
}

または
__getCount<N>Specials() {}
NormalAttackSpecialDict か DefenseSpecialDict を選択
__init__applySpecialSkillEffect() {}

戦闘後、奥義発動カウント-N
__applySkillEffectAfterCombatForUnit(targetUnit, enemyUnit) {
  targetUnit.specialCount -= N;
}


戦闘後、敵の周囲2マスの敵に7ダメージ[死の吐息]
__applyOverlappableSkillEffectFromAttackerAfterCombat(atkUnit, attackTargetUnit) {
    case PassiveC.SavageBlow3:
        for (let unit of this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(attackTargetUnit, 2)) {
            this.writeLogLine(unit.getNameWithGroup() + "は死の吐息により7ダメージ");
            unit.reserveTakeDamage(7);
        }
        break;
}

戦闘中、奥義による攻撃でダメージを与えた時、自分の最大HPの30%回復(与えたダメージが0でも効果は発動)
targetUnit.battleContext.maxHpRatioToHealBySpecial += 0.3;

攻撃ごとに変動する可能性のある戦闘中、奥義による攻撃でダメージを与えた時、自分の最大HPの30%回復(与えたダメージが0でも効果は発動)
__applySkillEffectsPerAttack(atkUnit, defUnit, canActivateAttackerSpecial) {
    atkUnit.battleContext.maxHpRatioToHealBySpecialPerAttack += 0.3;
}

奥義による攻撃でダメージを与えた時、N回復(与えたダメージが0でも効果は発動)
targetUnit.healedHpAfterAttackSpecialInCombat = N;

戦闘中と戦闘後、敵はHPを回復できない
targetUnit.battleContext.invalidatesHeal= true;

【回復不可】
unit.addStatusEffect(StatusEffectType.DeepWounds);

【回復不可】を60%無効
targetUnit.battleContext.nullInvalidatesHealRatio = 0.6

敵の奥義カウント変動量-1(キャンセル)
targetUnit.battleContext.reducesCooldownCount = true;

[拍節]
targetUnit.battleContext.applyInvalidationSkillEffectFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        enemyUnit.battleContext.increaseCooldownCountForAttack = false;
        enemyUnit.battleContext.increaseCooldownCountForDefense = false;
        enemyUnit.battleContext.reducesCooldownCount = false;
    }
);

自身の奥義発動カウント変動量-を無効
targetUnit.battleContext.applyInvalidationSkillEffectFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        enemyUnit.battleContext.reducesCooldownCount = false;
    }
);
もしくは
__applyInvalidationSkillEffect() {
    enemyUnit.battleContext.reducesCooldownCount = false;
}

敵の奥義発動カウント変動量+を無効
targetUnit.battleContext.applyInvalidationSkillEffectFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        enemyUnit.battleContext.increaseCooldownCountForAttack = false;
        enemyUnit.battleContext.increaseCooldownCountForDefense = false;
    }
);
もしくは
__applyInvalidationSkillEffect() {
    enemyUnit.battleContext.increaseCooldownCountForAttack = false;
    enemyUnit.battleContext.increaseCooldownCountForDefense = false;
}

自身の攻撃による奥義発動カウント変動量+1(同系統効果複数時、最大値適用)
atkUnit.battleContext.increaseCooldownCountForAttack = true;

戦闘中、自身の奥義発動カウント変動量+1
targetUnit.battleContext.increaseCooldownCountForBoth();

補助スキルを使用したとき、自身の奥義発動変動量は常に0
noEffectOnSpecialCooldownChargeOnSupportSkillSet.add(skillId);
このスキル使用時の奥義発動変動量は常に0
noEffectOnSpecialCooldownChargeOnSupportSkillSet.add(skillId);

奥義が発動しやすい(錬成武器)
resetMaxSpecialCountFuncMap.set(skillId,
    function () {
        // 特殊錬成の場合奥義が発動しやすい
        if (this.isWeaponSpecialRefined) {
            return -1;
        } else {
            return 0;
        }
    }
);
もしくは
resetMaxSpecialCount() {
    specialCountMax -= 1;
    // 奥義発動カウント最大値の下限は1
    if (specialCountMax === 0) {
        specialCountMax = 1;
    }
}

奥義発動可能状態
if (unit.isSpecialCharged) {}

奥義発動カウントが最大値なら、奥義発動カウント-N
if (this.__getStatusEvalUnit(skillOwner).isSpecialCountMax) {
    skillOwner.reduceSpecialCount(N);
}
// 戦闘後の時は
if (targetUnit.isSpecialCountMax) {
    targetUnit.reduceSpecialCount(N);
}

戦闘中、奥義発動可能状態の時、または、この戦闘(戦闘前、戦闘中)で奥義を発動済みの時(戦闘前奥義が含まれるのか注意すること)
atkUnit.isSpecialCharged || atkUnit.isSpecialActivated

自分の最初の攻撃前に自身の奥義発動カウント-N(符号に注意Nは自然数)
targetUnit.battleContext.specialCountReductionBeforeFirstAttack += N;

自分の最初の追撃前に奥義発動カウント-N(符号に注意Nは自然数)
targetUnit.battleContext.specialCountReductionBeforeFollowupAttack += N;

敵の最初の攻撃前に敵の奥義発動カウント+N(奥義発動カウントの最大値は超えない)[竜眼]
enemyUnit.battleContext.specialCountIncreaseBeforeFirstAttack += N;

奥義ダメージ+N
__init__applySpecialSkillEffect() {
    targetUnit.battleContext.specialAddDamage = N;
}

敵から攻撃を受ける際に発動する奥義を装備していたら
if (isDefenseSpecial(skillOwner.special)) {}

攻撃時発動の奥義装備時
if (isNormalAttackSpecial(skillOwner.special)) {}

戦闘中攻撃奥義を発動できない
enemyUnit.battleContext.preventedAttackerSpecial = true;

「敵から攻撃を受ける際に発動する奥義」を発動できない
enemyUnit.battleContext.preventedDefenderSpecial = true;

範囲奥義を発動できない
__applySkillEffectsBeforePrecombat(atkUnit, defUnit) {
    atkUnit.battleContext.cannotTriggerPrecombatSpecial = true;
}

自分または敵が奥義発動可能状態の時、または、この戦闘(戦闘前、戦闘中)で自分または敵が奥義発動済みの時、戦闘中、受けた攻撃のダメージを40%軽減(1戦闘1回のみ)(範囲奥義を除く)
applyDamageReductionRatiosWhenCondSatisfiedFuncMap.set(skillId,
    function (atkUnit, defUnit) {
        if (defUnit.tmpSpecialCount === 0 ||
            atkUnit.tmpSpecialCount === 0 ||
            defUnit.battleContext.isSpecialActivated ||
            atkUnit.battleContext.isSpecialActivated) {
            defUnit.battleContext.damageReductionRatiosWhenCondSatisfied.push(0.4);
        }
    }
);

支援効果を無効
atkUnit.battleContext.invalidatesSupportEffect = true;

周囲3マス以内に支援を結んでいる味方の組み合わせ(自分は含まない)がいる時
let units = Array.from(this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(targetUnit, 3));
let partners = units.map(u => u.partnerHeroIndex);
targetUnit.battleContext.isThereAnyPartnerPairsIn3Spaces |= units.some(u => partners.includes(u.heroIndex));
if (targetUnit.battleContext.isThereAnyPartnerPairsIn3Spaces) {}

敵の守備か魔防の低い方でダメージ計算(ブレスは実装不要)
targetUnit.battleContext.refersMinOfDefOrRes = true;

敵の守備か魔防の低い方でダメージ計算(魔弾など奥義発動時限定などはここで実装する)
__selectReferencingResOrDef(atkUnit, defUnit) {
}

敵の「敵の守備か魔防の低い方でダメージ計算」を無効化
__canInvalidatesReferenceLowerMit(targetUnit, enemyUnit) {}

ダメカ
受けた範囲奥義のダメージと、戦闘中に攻撃を受けた時のダメージを速さの差×N%軽減(最大M)[回避]
戦闘前
applyPrecombatDamageReductionRatioFuncMap.set(skillId,
    function (defUnit, atkUnit) {
        // 速度回避
        let ratio = DamageCalculationUtility.getDodgeDamageReductionRatioForPrecombat(atkUnit, defUnit);
        defUnit.battleContext.multDamageReductionRatioOfPrecombatSpecial(ratio);
    }
);
もしくは
__applyPrecombatDamageReductionRatio(defUnit, atkUnit) {
    {
        let ratio = DamageCalculationUtility.getDodgeDamageReductionRatioForPrecombat(atkUnit, defUnit, N, M);
        defUnit.battleContext.multDamageReductionRatioOfPrecombatSpecial(ratio);
        // 魔防参照
        let ratio = DamageCalculationUtility.getResDodgeDamageReductionRatioForPrecombat(atkUnit, defUnit, N, M);
        defUnit.battleContext.multDamageReductionRatioOfPrecombatSpecial(ratio);
    }
}
戦闘中
targetUnit.battleContext.getDamageReductionRatioFuncs.push((atkUnit, defUnit) => {
    return DamageCalculationUtility.getDodgeDamageReductionRatio(atkUnit, defUnit);
    // 魔防参照
    // return DamageCalculationUtility.getResDodgeDamageReductionRatio(atkUnit, defUnit);
    // 固定割合(30%)
    // return 0.3;
});
もしくは
__getDamageReductionRatio(skillId, atkUnit, defUnit) {
    return DamageCalculationUtility.getDodgeDamageReductionRatio(atkUnit, defUnit);
    // 魔防参照
    return DamageCalculationUtility.getResDodgeDamageReductionRatio(atkUnit, defUnit);
}

受けた範囲奥義のダメージをNだけ減少(巨影の範囲奥義除く)
__applyPrecombatDamageReduction(defUnit, atkUnit) {
    defUnit.battleContext.damageReductionForPrecombat += N;
}

連撃防御
targetUnit.battleContext.multDamageReductionRatioOfConsecutiveAttacks(0.8, enemyUnit);

戦闘中、最初に受けた攻撃のダメージを30%軽減
targetUnit.battleContext.multDamageReductionRatioOfFirstAttack(0.3, enemyUnit);

最初に受けた攻撃と2回攻撃のダメージを40%軽減
targetUnit.battleContext.multDamageReductionRatioOfFirstAttacks(0.4, enemyUnit);

最初に受けた攻撃と2回攻撃のダメージ-7(最初に受けた攻撃と2回攻撃:通常の攻撃は、1回目の攻撃のみ「2回攻撃」は、1~2回目の攻撃)
targetUnit.battleContext.damageReductionValueOfFirstAttacks += 7;

敵から受けた追撃のダメージを80%軽減(追撃:通常の武器は、2回目の攻撃、「2回攻撃」の武器は、3～4回目の攻撃)
targetUnit.battleContext.multDamageReductionRatioOfFollowupAttack(0.8, enemyUnit);

次の敵の攻撃のダメージを75%軽減(その戦闘中のみ)
__calcAttackTotalDamage(
    context, atkUnit, defUnit, attackCount, normalDamage, specialDamage,
    invalidatesDamageReductionExceptSpecialOnSpecialActivation,
    invalidatesDamageReductionExceptSpecial) {
    atkUnit.battleContext.damageReductionRatiosBySpecialOfNextAttack.push(0.75);
}

奥義による攻撃でダメージを与えた時、次の敵の攻撃のダメージを50%軽減(その戦闘中のみ)
// Weapon.ChildsCompass参照

__calcAttackTotalDamage(
    context, atkUnit, defUnit, attackCount, normalDamage, specialDamage,
    invalidatesDamageReductionExceptSpecialOnSpecialActivation,
    invalidatesDamageReductionExceptSpecial) {
    if (atkUnit.battleContext.damageReductionRatiosOfNextAttackWhenSpecialActivated !== null) {
        atkUnit.battleContext.damageReductionRatiosOfNextAttackWhenSpecialActivated.push(0.5);
    }
}

周囲2マス以内の味方は受けた攻撃のダメージを○%軽減(○は、戦闘開始時のスキル所持者のHPが100%なら、戦闘開始時のスキル所持者のHP、そうでない時は、スキル所持者の戦闘開始時のHP+2(端数切捨て)、最大60)(範囲奥義を除く)、かつ上記のダメージ軽減の効果が発動した場合、戦闘後、スキル所持者は1ダメージ(発動したダメージ軽減の効果が無効にされた場合でも、1ダメージを受ける)
applySkillEffectFromAlliesFuncMap.set(skillId,
    function (targetUnit, enemyUnit, allyUnit, calcPotentialDamage) {
        if (targetUnit.distance(allyUnit) <= 2) {
            let percentage = allyUnit.isFullHp ? allyUnit.hp : Math.trunc(allyUnit.hp / 2);
            let ratio = MathUtil.ensureMax(percentage, 60) / 100.0;
            targetUnit.battleContext.damageReductionRatiosByChainGuard.push([allyUnit, ratio]);
        }
    }
);

敵の奥義以外のスキルによる「ダメージを〇〇%軽減」を半分無効(無効にする数値は端数切捨て。例えば敵の「ダメージを45%軽減」なら半分の「22%」分を無効にし、「ダメージを23%軽減」にする))[リヴスラ, ダメージ軽減半分無効]
targetUnit.battleContext.reductionRatiosOfDamageReductionRatioExceptSpecial.push(0.5);

奥義以外のスキルによる「ダメージを〇〇%軽減」を無効(ダメージ加算、軽減無効は、範囲奥義を除く)
targetUnit.battleContext.invalidatesDamageReductionExceptSpecial = true;
// 次の攻撃
targetUnit.battleContext.invalidatesDamageReductionExceptSpecialForNextAttack = true;

追撃時、奥義以外のスキルによる「ダメージを〇〇%軽減」を無効(ダメージ加算、軽減無効は、範囲奥義を除く)
targetUnit.battleContext.invalidatesDamageReductionExceptSpecialForFollowupAttack = true;

敵から攻撃を受ける際に発動する奥義発動時、自分の次の攻撃は、敵の奥義以外のスキルによる「ダメージを○○%軽減」を無効(その戦闘中のみ)
targetUnit.battleContext.invalidatesDamageReductionExceptSpecialForNextAttackAfterDefenderSpecial = true;

奥義発動時、奥義以外のスキルによる「ダメージを〇〇%軽減」を無効(ダメージ加算、軽減無効は、範囲奥義を除く)
targetUnit.battleContext.invalidatesDamageReductionExceptSpecialOnSpecialActivation = true;

[螺旋効果]
applySkillEffectAfterCombatForUnitFuncMap.set(skillId,
    function(targetUnit, enemyUnit) {
        if (targetUnit.battleContext.isSpecialActivated) {
            targetUnit.specialCount -= 2;
        }
    }
);

与えるダメージ+自分の守備の20%、受けるダメージ-自分の守備の20%
targetUnit.battleContext.applySkillEffectForUnitForUnitAfterCombatStatusFixedFuncs.push(
    (targetUnit, enemyUnit, calcPotentialDamage) => {
        targetUnit.battleContext.additionalDamage += Math.trunc(targetUnit.getEvalDefInCombat(enemyUnit) * 0.20);
        targetUnit.battleContext.damageReductionValue += Math.trunc(targetUnit.getEvalDefInCombat(enemyUnit) * 0.20);
    }
);

戦闘中、最初に与える攻撃のダメージに...
targetUnit.battleContext.additionalDamageOfFirstAttack += ...

戦闘開始後にNダメージ(戦闘中にダメージを減らす効果の対象外、ダメージ後のHPは最低1)
// ダメージを受けるのはenemyUnit
enemyUnit.battleContext.damageAfterBeginningOfCombat += N;

ダメージ+N(固定ダメージ) （同名のメソッドがあるので注意すること）
// 戦闘開始時にも対応
calcFixedAddDamageFuncMap.set(skillId,
    function (atkUnit, defUnit, isPrecombat) {
        // Nダメージ
        atkUnit.battleContext.additionalDamage += N;
        // ステータスの20%(奥義含む。含まない場合はisPrecombatで条件わけする)
        // if (isPrecombat) return;
        let status = DamageCalculatorWrapper.__get<XXX>(atkUnit, defUnit, isPrecombat);
        atkUnit.battleContext.additionalDamage += Math.trunc(status * 0.2);
    }
);
もしくは
// 戦闘開始後に呼ばれるので戦闘前奥義は__calcFixedAddDamageに直接実装すること
targetUnit.battleContext.calcFixedAddDamageFuncs.push((atkUnit, defUnit, isPrecombat) => {
    // Nダメージ
    atkUnit.battleContext.additionalDamage += N;
    // ステータスの20%(奥義含む。含まない場合はisPrecombatで条件わけする)
    // if (isPrecombat) return;
    let status = DamageCalculatorWrapper.__getX(atkUnit, defUnit, isPrecombat);
    atkUnit.battleContext.additionalDamage += Math.trunc(status * 0.2);
});
もしくは
DamageCalculatorWrapper.js
__calcFixedAddDamage(atkUnit, defUnit, isPrecombat) {
    // Nダメージ
    atkUnit.battleContext.additionalDamage += N;
    // 速さが敵より1以上高い時ダメージ+N(戦闘前奥義も含む)
    if (DamageCalculatorWrapper.__getSpd(atkUnit, defUnit, isPrecombat) >
        DamageCalculatorWrapper.__getSpd(defUnit, atkUnit, isPrecombat)) {
        atkUnit.battleContext.additionalDamage += N;
    }
    // 速さが敵より高ければ、ダメージ+速さの差のN%(最大M)
    atkUnit.battleContext.additionalDamage += DamageCalculatorWrapper.__calcAddDamageForDiffOfNPercent(
        atkUnit, defUnit, isPrecombat,
        x => x.getEvalSpdInPrecombat(),
        (x, y) => x.getEvalSpdInCombat(y)
        N / 100, M);
    }
}
1回ごとの攻撃で呼ばれる
DamageCalculator.js
__calcFixedAddDamage(atkUnit, defUnit, isPrecombat) {
    fixedAddDamage += N;
}

固定ダメージ軽減
targetUnit.battleContext.damageReductionValue += N;

追撃の固定ダメージ軽減
targetUnit.battleContext.damageReductionValueOfFollowupAttack += N;

最初に受けた攻撃の固定ダメージ軽減
targetUnit.battleContext.damageReductionValueOfFirstAttacks += N;

奥義発動時、ダメージ+N
// 呼び出し順序によりこの方法は範囲奥義を除く場合にしか使用できない
targetUnit.battleContext.calcFixedAddDamageFuncs.push((atkUnit, defUnit, isPrecombat) => {
    targetUnit.battleContext.additionalDamageOfSpecial += N;
});
もしくは
__calcFixedSpecialAddDamage(targetUnit, enemyUnit, isPrecombat = false) {
    targetUnit.battleContext.additionalDamageOfSpecial += N;
}

奥義によるダメージ+N
__calcFixedSpecialAddDamage() {
    targetUnit.battleContext.additionalDamageOfSpecial += N;
}

最初の受けた攻撃のダメージをN%軽減し、軽減した値を、自身の次の攻撃のダメージに加算(他のスキルによる軽減値も含む)(その戦闘中のみ)
__init__applySkillEffectForUnitFuncDict() {
    // 最初に受けた攻撃のダメージを軽減
    targetUnit.battleContext.multDamageReductionRatioOfFirstAttack(N / 100.0, enemyUnit);
    // ダメージ軽減分を保存
    targetUnit.battleContext.addReducedDamageForNextAttackFuncs.push(
        (defUnit, atkUnit, damage, currentDamage, activatesDefenderSpecial, context) => {
            if (!context.isFirstAttack(atkUnit)) return;
            defUnit.battleContext.nextAttackAddReducedDamageActivated = true;
            defUnit.battleContext.reducedDamageForNextAttack = damage - currentDamage;
        }
    );
    // 攻撃ごとの固定ダメージに軽減した分を加算
    targetUnit.battleContext.calcFixedAddDamagePerAttackFuncs.push((atkUnit, defUnit, isPrecombat) => {
        if (atkUnit.battleContext.nextAttackAddReducedDamageActivated) {
            atkUnit.battleContext.nextAttackAddReducedDamageActivated = false;
            let addDamage = atkUnit.battleContext.reducedDamageForNextAttack;
            atkUnit.battleContext.reducedDamageForNextAttack = 0;
            return addDamage;
        }
        return 0;
    });
}

// 防御系奥義以外の奥義によるダメージ軽減
targetUnit.battleContext.damageReductionRatiosByNonDefenderSpecial.push(ratio);

最初に攻撃を受けた時、戦闘中、軽減前のダメージの30%を自身の次の攻撃のダメージに+(その戦闘中のみ。同系統効果複数時、最大値適用)
targetUnit.battleContext.reducedRatioForNextAttack = Math.max(0.3, targetUnit.battleContext.reducedRatioForNextAttack);

ダメージをHPが1残るように軽減(奥義以外の祈り)
targetUnit.battleContext.canActivateNonSpecialMiracleFuncs.push((defUnit, atkUnit) => {
    // 1戦闘1回まで
    if (defUnit.battleContext.isNonSpecialMiracleActivated) {
        return false;
    }
    return defUnit.battleContext.restHpPercentage >= 50;
});

奥義以外の祈り+99回復
if (g_appData.globalBattleContext.miracleAndHealWithoutSpecialActivationCount[targetUnit.groupId] === 0) {
    targetUnit.battleContext.canActivateNonSpecialMiracleAndHeal = true;
}

奥義以外の祈り無効
targetUnit.battleContext.neutralizesNonSpecialMiracle = true;

戦闘中に攻撃していれば
targetUnit.battleContext.applyAttackSkillEffectAfterCombatNeverthelessDeadForUnitFuncs.push(
    (attackUnit, attackTargetUnit, result) => {
    }
);
もしくは
__applyAttackSkillEffectAfterCombatNeverthelessDeadForUnit(attackUnit, attackTargetUnit) {}

戦闘で奥義を発動した場合、戦闘後、戦闘相手とその周囲1マスの敵に【グラビティ】を付与
// 攻撃奥義の場合
// 攻撃を受けた際に発動する奥義の場合はapplySkillEffectAfterCombatNeverthelessDeadForUnitFuncMapを使用する
applyAttackSkillEffectAfterCombatNeverthelessDeadForUnitFuncMap.set(skillId,
    function (attackUnit, attackTargetUnit) {
        if (attackUnit.battleContext.isSpecialActivated) {
            /** @type {[Unit]} */
            let units = this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(attackTargetUnit, 2, true);
            for (let unit of units) {
                unit.addStatusEffect(StatusEffectType.Gravity);
            }
        }
    }
);

戦闘を行なっている時[戦闘を行っていない時]
unit.isCombatDone

戦闘後の移動スキル[叩き込み、切り込み、一撃離脱など]
applyMovementSkillAfterCombatFuncMap.set(skillId,
    function (atkUnit, attackTargetUnit, executesTrap) {
        // (例) レイラのスキル
        let partners = this.__getPartnersInSpecifiedRange(atkUnit, 2);
        if (partners.length === 1) {
            let partner = partners[0];
            let func = (unit, target, tile) => this.__findTileAfterSwap(unit, target, tile);
            return this.__applyMovementAssist(atkUnit, partner, func, false, true, executesTrap);
        }
        return false;
    }
);

対象を行動可能な状態にする時のスキル[「歌う」「踊る」使用時]
applyRefreshFuncMap.set(skillId,
    function (skillOwnerUnit, targetUnit) {
    }
);
もしくは
__applyRefresh(skillOwnerUnit, targetUnit) {}

このスキルは「歌う」「踊る｣として扱われる。「歌う」「踊る」を持つ対象には使用できない。対象を行動可能な状態にする。
refreshSupportSkillSet.add(skillId);
もしくは
function isRefreshSupportSkill(skillId) {return true;}

移動系補助(体当たり、引き戻し、回り込み等)を使用した時、または自分に使用された時
applyMovementAssistSkillFuncMap.set(skillId,
    function (unit1, unit2) {
    }
);
または
__applyMovementAssistSkill() {}

応援を使用した時、または自分に使用された時
// 使用した時
applySkillsAfterRallyForSupporterFuncMap.set(skillId,
    function (supporterUnit, targetUnit) {
    }
);
// 使用された時
applySkillsAfterRallyForTargetUnitFuncMap.set(skillId,
    function (supporterUnit, targetUnit) {
    }
);
または
__applySkillsAfterRally(supporterUnit, targetUnit) {}

応援を使用した時、自分を行動可能にする(1ターンに1回のみ)
applySupportSkillFuncMap.set(skillId,
    function (supporterUnit, targetUnit) {
        if (!supporterUnit.isOneTimeActionActivatedForWeapon) {
            supporterUnit.isActionDone = false;
            supporterUnit.isOneTimeActionActivatedForWeapon = true;
        }
    }
);

// 共謀系[強制応援]
// 応援をかける側
canRallyForciblyFuncMap.set(skillId,
    function (unit) {
        return true;
    }
);
// 応援をかけられた時
canRalliedForciblyFuncMap.set(skillId,
    function (unit) {
        return true;
    }
);

自分を除く自軍内の移動タイプの種類数によって異なる効果を発動
enumerateUnitsInTheSameGroupOnMap()
let sameMoveTypeCount = 0;
for (let otherUnit of this.enumerateUnitsInTheSameGroupOnMap(unit)) {
    if (otherUnit.moveType == unit.moveType) { ++sameMoveTypeCount; }
}

上記の効果は、各自軍ターン、各敵軍ターンそれぞれについて、このスキル所持者の最初の戦闘のみ
targetUnit.isOneTimeActionActivatedForWeapon

各ターンについて、このスキル所持者が自分から攻撃した最初の戦闘と敵から攻撃された最初の戦闘の時のみ
setOnetimeActionActivatedFuncMap.set(skillId,
    function () {
        if (this.battleContext.initiatesCombat) {
            this.isOneTimeActionActivatedForWeapon = true;
        } else {
            this.isOneTimeActionActivatedForWeapon2 = true;
        }
    }
);

戦闘後、自分を行動可能にする(1ターンに1回のみ)[再行動]
applySkillEffectAfterMovementSkillsActivatedFuncMap.set(skillId,
    function (atkUnit, defUnit, tileToAttack) {
        if (atkUnit.battleContext.initiatesCombat) {
            // Bスキルでの再行動
            if (!atkUnit.isOneTimeActionActivatedForPassiveB &&
                atkUnit.isActionDone ) {
                this.writeLogLine(`${atkUnit.getNameWithGroup()}は${atkUnit.passiveBInfo.name}により再行動`);
                atkUnit.isActionDone = false;
                atkUnit.isOneTimeActionActivatedForPassiveB = true;
            }
        }
    }
);
もしくは
updateDamageCalculation(atkUnit, defUnit, tileToAttack = null) {
    // case Weapon.TwinCrestPower:
    // case PassiveB.RagingStorm:
}

入れ替え
getTargetUnitTileAfterMoveAssistFuncMap.set(skillId, function (unit, targetUnit, assistTile) {
    return this.__findTileAfterSwap(unit, targetUnit, assistTile);
});
findTileAfterMovementAssistFuncMap.set(skillId, function (unit, target, tile) {
    return this.__findTileAfterSwap(unit, target, tile);
});

補助後、自分を行動可能にする[再行動]
applySupportSkillForSupporterFuncMap.set(skillId,
    function (supporterUnit, targetUnit, supportTile) {
        if (!supporterUnit.isOneTimeActionActivatedForSupport) {
            supporterUnit.isActionDone = false;
            supporterUnit.isOneTimeActionActivatedForSupport = true;
        }
    }
);
もしくは
applySupportSkill() {
    // case Support.FutureVision
}

進軍阻止・防壁
進軍阻止(1マス)
canActivateObstructToAdjacentTilesFuncMap.set(skillId,
    function (unit, moveUnit) {
        return true;
    }
);

進軍阻止(2マス)
canActivateObstractToTilesIn2SpacesFuncMap.set(skillId,
    function (unit, moveUnit) {
        return true;
    }
);

自身が移動可能な地形を平地のように移動可能
Tile.js
getMoveWeight() {
    if (weight !== CanNotReachTile && weight !== 0) {
        weight = 1;
    }
}

再移動(N)
canActivateCantoFuncMap.set(skillId, function (unit) {
    // 無条件再移動
    return true;
});
calcMoveCountForCantoFuncMap.set(skillId, function () {
    // thisはUnit
    // 再移動N
    return N;
    // 再移動残り+1
    // return this.restMoveCount + 1;
    // マス間の距離+1、最大4
    // let dist = Unit.calcMoveDistance(this)
    // return Math.min(dist + 1, 4);
});
もしくは
__canActivateCanto(unit) {}
unit.calcMoveCountForCanto() {} // ワープの場合は必要なし

再移動(ワープ)
* enumerateWarpCantoTiles(unit) {}

移動可能[ワープ]
// const TeleportationSkillDictに登録
TeleportationSkillDict[skillId] = 0;
enumerateTeleportTilesForUnitFuncMap.set(skillId,
    function (unit) {
        // 周囲2マス以内の味方の、周囲1マス以内に移動可能
        return this.__enumeratesSpacesWithinSpecificSpacesOfAnyAllyWithinSpecificSpaces(unit, 2, 1);
        // 周囲4マス以内にいる敵の隣接マスのうち、自分から最も近いマスに移動可能(敵ごとに判定、その最も近いマスについて、自分が移動できない地形の場合は移動できない)
        return this.enumerateNearestTileForEachEnemyWithinSpecificSpaces(unit, 4);
    }
);
// 周囲2マス以内の味方は自身の周囲2マス以内に移動可能
enumerateTeleportTilesForAllyFuncMap.set(skillId,
    function(targetUnit, allyUnit) {
        // 周囲2マス以内の味方は自身の周囲2マス以内に移動可能
        if (targetUnit.distance(allyUnit) <= 2) {
            return this.__enumeratePlacableTilesWithinSpecifiedSpaces(allyUnit.placedTile, targetUnit, 2);
        } else {
            return this.__enumerateNoTiles();
        }
    }
);
もしくは
Main.js
*__enumerateTeleportTiles(unit) {
    // 周囲2マス以内の味方の、周囲2マス以内に移動可能(PassiveC.OpeningRetainer)
    for (let ally of this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(unit, 2)) {
        for (let tile of this.__enumeratePlacableTilesWithinSpecifiedSpaces(ally.placedTile, unit, 2)) {
            yield tile;
        }
    }
    // もしくは
    // 周囲nマス以内の味方の、周囲mマス以内に移動可能
    yield* this.__enumeratesSpacesWithinSpecificSpacesOfAnyAllyWithinSpecificSpaces(unit, n, m);
    yield* this.__enumeratesSpacesWithinSpecificSpacesOfAnyAllyWithinSpecificSpaces(unit); // 2, 2
    // 曲技飛行
    let allyCondFunc = ally =>
        [MoveType.Armor, MoveType.Infantry, MoveType.Cavalry].includes(ally.moveType);
    yield* this.__enumeratesSpacesWithinSpecificSpacesOfAnyAllyWithinSpecificSpaces(
        unit, 2, 1, allyCondFunc
    );
}

救援の行路
離脱の行路
*__enumerateTeleportTiles(unit) {
    // 救援
    for (let ally of this.enumerateUnitsInTheSameGroup(unit)) {
        yield* ally.placedTile.getMovableNeighborTiles(unit, 1, false, true);
    }
    // 離脱
    yield* this.__enumerateEscapeRoute(unit);
}

天駆の道
function hasPathfinderEffect(skillId) {}

攻撃した側(自分からなら自分、敵からなら敵)の移動前と移動後のマスの距離[激突]
let dist = Unit.calcAttackerMoveDistance(targetUnit, enemyUnit);

移動前と移動後のマスの距離
let dist = Unit.calcMoveDistance(targetUnit);

神竜の花を自身に使用した回数がN回
targetUnit.dragonflower === N

護り手
護り手を発動させないタイプのスキルの場合以下のメソッドは使えない
canActivateSaveSkillFuncMap.set(skillId,
    function (atkUnit, unit) {
        // 遠間
        return atkUnit.isRangedWeaponType();
    }
);
もしくは
__canActivateSaveSkill(atkUnit, unit) {
    return true;
}

護り手が発動している時
if (targetUnit.battleContext.isSaviorActivated) {
}

[アフリクター]
isAfflictorFuncMap.set(skillId,
    function (attackUnit, lossesInCombat) {
        // 死んでいなければ
        return !lossesInCombat;
    }
);
もしくは
function isAfflictor(attackUnit, lossesInCombat) {
}

【XXX】の状態を付与(ステータス追加)
Unit.js
const StatusEffectType = {
    XXX: YYY, // XXX
}
function statusEffectTypeToIconFilePath(value) {
    case StatusEffectType.XXX:
    return g_imageRootPath + "XXX.png";
}
/// ステータス効果が不利なステータス効果であるかどうかを判定
// 不利なステータス異常の場合はNegativeStatusEffectTableに登録すること
// 有利な場合は不要
function isNegativeStatusEffect(type) {}

ステータス付与
Main.js
unit.reserveToAddStatusEffect(StatusEffectType.XXX);

天脈を予約
tile.reserveDivineVein(DivineVeinType.Green, unit.groupId);

予約された天脈を付与
g_appData.map.applyReservedDivineVein();

出典の配列を返す
unit.getOrigins();

ユーザーリストから出典の集合を得る
Unit.getOriginSet(units);

周囲3マス以内の味方の出典の種類数
let units = this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(targetUnit, 3);
let num = Unit.getOriginSet(units).size;

比翼・双界英雄
Unit.js
const Hero = {
    XXX: YYY,
}
Main.js
    __activateDuoOrHarmonizedSkill(duoUnit) {
        // 同じ出典のキャラクターに付与
        this.__addStatusEffectToSameOriginUnits(duoUnit, StatusEffectType.ZZZ);
    }
再使用
__initializeUnitsPerTurn(targetUnits) {}

ターン毎のインポート、エクスポート設定
fromPerTurnStatusString(value) {}
perTurnStatusToString() {}

新マップ追加
1. MapTypeに新マップを追加
2. mapKindOptionsにオプションを追加
3. AetherRaidMapImageFilesに画像を追加
4. tileTypeToThumbを修正
5. getMapBackgroundImage
6. getBreakableObjCountOfCurrentMapType(壊れる壁の数)を修正
7. __resetBattleMapPlacementForAetherRaidで特殊なタイルを設定(x: 左から0~, y: 上から0~)
画像は海外wikiから取得する。例えばK0017は以下のURLで取得できる。
https://feheroes.fandom.com/wiki/Category:Aether_Raids_map_files?file=Map_K0017.webp

[注意]
https://feheroes.fandom.com/wiki/Category:Aether_Raids_map_files
だと何故か新しいマップは一覧に出てこない。

関数マップテンプレ
let funcMap = xxxMap;
if (funcMap.has(skillId)) {
    let func = funcMap.get(skillId);
    if (typeof func === "function") {
        let result = func.call(this, args);
    } else {
        console.warn(`登録された関数が間違っています。key: ${skillId}, value: ${func}, type: ${typeof func}`);
    }
}
