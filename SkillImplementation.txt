コピペ用(スキル効果=>実装コード)

<錬成武器判定>
if (targetUnit.isWeaponRefined) {}
<特殊錬成武器判定>
if (targetUnit.isWeaponSpecialRefined) {}
武器錬成テンプレ
if (!targetUnit.isWeaponRefined) {
    // <通常効果>
} else {
    // <錬成効果>
    if (targetUnit.isWeaponSpecialRefined) {
        // <特殊錬成効果>
    }
}
武器錬成(錬成効果追加のみ)
if (targetUnit.isWeaponRefined) {
    // <錬成効果>
    if (targetUnit.isWeaponSpecialRefined) {
        // <特殊錬成効果>
    }
}

化身状態なら
if (targetUnit.isTransformed) {}

ターン開始時(通常)
applySkillForBeginningOfTurn(skillId, skillOwner) {}
ターン開始時(回復)
applyHealSkillForBeginningOfTurn(skillId, skillOwner) {}
ターン開始時(ダメージ)
applyDamageSkillForBeginningOfTurn(skillId, skillOwner) {}

獣の共通の化身スキル
const WeaponTypesAddAtk2AfterTransform = {};
WeaponTypesAddAtk2AfterTransform[Weapon.XXX] = 0;
const BeastCommonSkillMap =
    new Map([
            [Weapon.XXX, BeastCommonSkillType.YYY],

敵が赤属性の時
if (enemyUnit.color === ColorType.Red)

3すくみ有利だと、さらに攻撃+20%[相性激化]
getTriangleAdeptAdditionalRatio() {
    if (isTriangleAdeptSkill(this.passiveA)
        || isTriangleAdeptSkill(this.weapon)
        || (this.weapon === Weapon.Forukuvangu && this.isWeaponSpecialRefined)
        || (this.weapon === Weapon.TomeOfOrder && this.isWeaponSpecialRefined)
        || this.hasStatusEffect(StatusEffectType.TriangleAdept)
    ) {
        return 0.2;
    }
}

敵が歩行、飛行、騎馬、重装の時
if (enemyUnit.moveType === MoveType.Infantry) {}
if (enemyUnit.moveType === MoveType.Flying) {}
if (enemyUnit.moveType === MoveType.Cavalry) {}
if (enemyUnit.moveType === MoveType.Armor:) {}

自分から攻撃した時
if (targetUnit.battleContext.initiatesCombat) {
敵から攻撃された時
if (enemyUnit.battleContext.initiatesCombat) {

周囲2マス以内に味方がいる時
if (__isThereAllyIn2Spaces(targetUnit)) {}

周囲Nマス以内に味方がいる時
if (this.__isThereAllyInSpecifiedSpaces(targetUnit, N)) {}

周囲1マス以内に味方がいない時(孤軍)
if (this.__isSolo(targetUnit) || calcPotentialDamage) {}

周囲Nマス以内にいる、最も近い敵
for (let unit of this.__findNearestEnemies(<unit>, <N>)) {}

戦闘中バフ(N)
targetUnit.addAllSpur(N)
targetUnit.atkSpur += N
enemyUnit.atkSpur -= N

周囲2マス以内の味方は、戦闘中、<ステ>+N
__addSpurInRange2(targetUnit, allyUnit, calcPotentialDamage) {
    for (let skillId of allyUnit.enumerateSkills()) {
        if (!calcPotentialDamage) {
            switch (skillId) {
                case XXX.YYY:
                    targetUnit.atkSpur += N;

周囲2マス以内に味方がいる時、戦闘中、自身の<ステ>+N
__addSelfSpurIfAllyAvailableInRange2(targetUnit, skillId, calcPotentialDamage) {
    if (!calcPotentialDamage) {
        switch (skillId) {
            case XXX.YYY:
                targetUnit.atkSpur += N;

周囲2マス以内の味方は、戦闘中、<バフ以外の効果>
__applySkillEffectFromAllies(targetUnit, enemyUnit, calcPotentialDamage) {
    // <バフ以外の効果>
}

周囲3マス以内の敵は、戦闘中、<ステータス>-N
__updateUnitSpur() {
    for (let unit of this.enumerateUnitsInDifferentGroupWithinSpecifiedSpaces(targetUnit, 3)) {
        targetUnit.xxxSpur -= N;
    }
}

<ステータス>+N (距離に関係の無い)
__updateUnitSpur() {}

戦闘開始時、自身(敵)のHPがN%以上なら
targetUnit.battleContext.restHpPercentage >= N
enemyUnit.battleContext.restHpPercentage >= N

速さが敵よりN以上高い時
__applySkillEffectForUnitAfterCombatStatusFixed() {
    if (targetUnit.getEvalSpdInCombat() >= enemyUnit.getEvalSpdInCombat() + N) {
    }
}

2回攻撃
__setAttackCount(atkUnit, enemyUnit) {
    // 攻撃時
    atkUnit.battleContext.attackCount = 2;
    // 攻撃を受けた時
    atkUnit.battleContext.counterattackCount = 2;
}

追撃可能なら自分の攻撃の直後に追撃を行う(攻め立て)
__applyChangingAttackPrioritySkillEffects(atkUnit, defUnit) {
    atkUnit.battleContext.isDesperationActivatable = true;
}

敵から攻撃された時、先制攻撃[待ち伏せ]
targetUnit.battleContext.isVantageActivatable = true;

自身の戦闘順入替スキル(待ち伏せ、攻め立て等)無効、敵の戦闘順入替スキル(待ち伏せ、攻め立て等)無効[不動の姿勢]
canDisableAttackOrderSwapSkill(restHpPercentage) {
    return true;
}


絶対追撃
targetUnit.battleContext.followupAttackPriorityIncrement++;

敵は追撃不可
enemyUnit.battleContext.followupAttackPriorityDecrement--;

敵の絶対追撃を無効
targetUnit.battleContext.invalidatesAbsoluteFollowupAttack = true;

自身の追撃不可を無効
targetUnit.battleContext.invalidatesInvalidationOfFollowupAttack = true;

反撃不可
static __canDisableCounterAttack(atkUnit, defUnit) {
    return true;
}

戦闘中、自分が受けている反撃不可を無効
__canDisableCounterAttack(atkUnit, defUnit) {
    return false;
}

自分が受けている攻撃、速さ、守備、魔防の強化の値だけ上昇(強化増幅)
__applySkillEffectForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    DamageCalculatorWrapper.__applyBonusDoubler(targetUnit, enemyUnit);
}

敵の強化の+を無効(強化無効)
targetUnit.battleContext.invalidateAllBuffs();
targetUnit.battleContext.invalidatesAtkBuff = true;

自身の弱化を無効(弱化無効)
targetUnit.battleContext.invalidateAllOwnDebuffs();
targetUnit.battleContext.invalidatesOwnAtkDebuff = true;

自分が弱化を受けていれば、能力値が弱化の値の2倍だけ上昇(能力値ごとに計算)(例えば、攻撃-7の弱化を受けていれば、-7+14+4で、戦闘中、攻撃+11となる)[弱化反転]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    case Weapon.ShinkenFalcion:
    case Weapon.ChaosRagnell:
        {
            let atkAdd = Math.abs(targetUnit.atkDebuffTotal) * 2;
            let spdAdd = Math.abs(targetUnit.spdDebuffTotal) * 2;
            let defAdd = Math.abs(targetUnit.defDebuffTotal) * 2;
            let resAdd = Math.abs(targetUnit.resDebuffTotal) * 2;
            if (this.isLogEnabled) this.__writeDamageCalcDebugLog(`${targetUnit.weaponInfo.name}により攻+${atkAdd}, 速+${spdAdd}, 守+${defAdd}, 魔+${resAdd}`);
            targetUnit.atkSpur += atkAdd;
            targetUnit.spdSpur += spdAdd;
            targetUnit.defSpur += defAdd;
            targetUnit.resSpur += resAdd;
        }
        break;
}

弱化を受けていれば、戦闘中、敵の弱化の値だけ減少(能力値ごとに計算)(例えば、攻撃-7の弱化を受けていれば、-7-7で、戦闘中、攻撃-14となる)[弱化増幅]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    enemyUnit.atkSpur -= Math.abs(enemyUnit.atkDebuffTotal);
    enemyUnit.spdSpur -= Math.abs(enemyUnit.spdDebuffTotal);
    enemyUnit.defSpur -= Math.abs(enemyUnit.defDebuffTotal);
    enemyUnit.resSpur -= Math.abs(enemyUnit.resDebuffTotal);
}

強化の値の2倍だけ減少[強化反転]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    enemyUnit.atkSpur -= Math.max(enemyUnit.getAtkBuffInCombat(targetUnit), 0) * 2;
    enemyUnit.spdSpur -= Math.max(enemyUnit.getSpdBuffInCombat(targetUnit), 0) * 2;
    enemyUnit.defSpur -= Math.max(enemyUnit.getDefBuffInCombat(targetUnit), 0) * 2;
    enemyUnit.resSpur -= Math.max(enemyUnit.getResBuffInCombat(targetUnit), 0) * 2;
}

敵が受けている強化の合計値を攻撃に加算[敵ブレード]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    targetUnit.atkSpur += Math.max(enemyUnit.getBuffTotalInCombat(targetUnit), 0);
}

敵が受けている弱化の合計値を自分の攻撃に加算[弱化ブレード]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    DamageCalculationUtility.applyDebuffBlade(targetUnit, enemyUnit);
}

敵が強化を受けていれば、戦闘中、自身の攻撃、速さ、守備、魔防が敵が受けている強化の値だけ上昇(能力値ごとに計算)[敵強化増幅]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    targetUnit.atkSpur += enemyUnit.getAtkBuffInCombat(targetUnit);
    targetUnit.spdSpur += enemyUnit.getSpdBuffInCombat(targetUnit);
    targetUnit.defSpur += enemyUnit.getDefBuffInCombat(targetUnit);
    targetUnit.resSpur += enemyUnit.getResBuffInCombat(targetUnit);
}

敵の攻撃、速さ、守備、魔防が敵が受けている強化の値だけ減少(能力値ごとに計算)[敵強化減少]
__applySpurForUnitAfterCombatStatusFixed(targetUnit, enemyUnit, calcPotentialDamage) {
    targetUnit.atkSpur += enemyUnit.getAtkBuffInCombat(targetUnit);
    targetUnit.spdSpur += enemyUnit.getSpdBuffInCombat(targetUnit);
    targetUnit.defSpur += enemyUnit.getDefBuffInCombat(targetUnit);
    targetUnit.resSpur += enemyUnit.getResBuffInCombat(targetUnit);
}

敵が[有利/不利]な状態異常を受けている時
__applySkillEffectRelatedToEnemyStatusEffects(targetUnit, enemyUnit, calcPotentialDamage) {
   if (enemyUnit.hasPositiveStatusEffect(targetUnit)) {}
   if (enemyUnit.hasNegativeStatusEffect()) {}
}

HP N回復
targetUnit.reserveHeal(N);

自分の攻撃でダメージを与えた時、自分のHP N回復(与えたダメージが0でも効果は発動)
targetUnit.battleContext.healedHpByAttack = N

戦闘後、HP N回復
__applySkillEffectAfterCombatForUnit() {
  targetUnit.reserveHeal(N);
}

戦闘中、奥義による攻撃でダメージを与えた時、自分の最大HPの30%回復(与えたダメージが0でも効果は発動)
targetUnit.battleContext.maxHpRatioToHealBySpecial += 0.3;

戦闘中と戦闘後、敵はHPを回復できない
targetUnit.battleContext.invalidatesHeal= true;

【回復不可】
unit.addStatusEffect(StatusEffectType.DeepWounds);

敵の奥義カウント変動量-1(キャンセル)
targetUnit.battleContext.reducesCooldownCount = true;

自身の奥義発動カウント変動量-を無効
__applyInvalidationSkillEffect() {
    defUnit.battleContext.reducesCooldownCount = false;
}

敵の奥義発動カウント変動量+を無効
__applyInvalidationSkillEffect() {
    defUnit.battleContext.increaseCooldownCountForAttack = false;
    defUnit.battleContext.increaseCooldownCountForDefense = false;
}

自身の攻撃による奥義発動カウント変動量+1(同系統効果複数時、最大値適用)
atkUnit.battleContext.increaseCooldownCountForAttack = true;

戦闘中、自身の奥義発動カウント変動量+1
targetUnit.battleContext.increaseCooldownCountForBoth();

奥義が発動しやすい(錬成武器)
resetMaxSpecialCount() {
    specialCountMax -= 1;
}

周囲3マス以内に支援を結んでいる味方の組み合わせ(自分は含まない)がいる時
let units = Array.from(this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(targetUnit, 3));
let partners = units.map(u => u.partnerHeroIndex);
targetUnit.battleContext.isThereAnyPartnerPairsIn3Spaces |= units.some(u => partners.includes(u.heroIndex));
if (targetUnit.battleContext.isThereAnyPartnerPairsIn3Spaces) {}

敵の守備か魔防の低い方でダメージ計算(ブレスは実装不要)
targetUnit.battleContext.refersMinOfDefOrRes = true;

受けた範囲奥義のダメージと、戦闘中に攻撃を受けた時のダメージを速さの差×N%軽減(最大M)[回避]
戦闘前
__applyPrecombatDamageReductionRatio(defUnit, atkUnit) {
    {
        let ratio = DamageCalculationUtility.getDodgeDamageReductionRatioForPrecombat(atkUnit, defUnit, N, M);
        defUnit.battleContext.multDamageReductionRatioOfPrecombatSpecial(ratio);
    }
}
戦闘中
__getDamageReductionRatio(skillId, atkUnit, defUnit) {
    return DamageCalculationUtility.getDodgeDamageReductionRatio(atkUnit, defUnit);
}

戦闘中、最初に受けた攻撃のダメージを30%軽減
targetUnit.battleContext.multDamageReductionRatioOfFirstAttack(0.3, enemyUnit);

敵から受けた追撃のダメージを80%軽減(追撃:通常の武器は、2回目の攻撃、「2回攻撃」の武器は、3～4回目の攻撃)
targetUnit.battleContext.multDamageReductionRatioOfFollowupAttack(0.8, enemyUnit);

奥義発動時、奥義以外のスキルによる「ダメージを〇〇%軽減」を無効(ダメージ加算、軽減無効は、範囲奥義を除く)
targetUnit.battleContext.invalidatesDamageReductionExceptSpecialOnSpecialActivation = true;

戦闘中、最初に与える攻撃のダメージに...
targetUnit.battleContext.additionalDamageOfFirstAttack += ...

ダメージ+N(固定ダメージ)
DamageCalculatorWrapper.js
__calcFixedAddDamage(atkUnit, defUnit, isPrecombat) {
    // Nダメージ
    atkUnit.battleContext.additionalDamage += N;
    // 速さが敵より1以上高い時ダメージ+N(戦闘前奥義も含む)
    if (DamageCalculatorWrapper.__getSpd(atkUnit, defUnit, isPrecombat) >
        DamageCalculatorWrapper.__getSpd(defUnit, atkUnit, isPrecombat)) {
        atkUnit.battleContext.additionalDamage += N;
    }
    // 速さが敵より高ければ、ダメージ+速さの差のN%(最大M)
    atkUnit.battleContext.additionalDamage += DamageCalculatorWrapper.__calcAddDamageForDiffOfNPercent(
        atkUnit, defUnit, isPrecombat,
        x => x.getEvalSpdInPrecombat(),
        (x, y) => x.getEvalSpdInCombat(y)
        N / 100, M);
    }
}

奥義発動時、ダメージ+N
__calcFixedSpecialAddDamage(targetUnit, enemyUnit, isPrecombat = false) {
    targetUnit.battleContext.additionalDamageOfSpecial += N
}

奥義によるダメージ+N
__calcFixedSpecialAddDamage() {
    fixedSpecialAddDamage += N;
}

ダメージをHPが1残るように軽減(祈り)
__canActivateMiracle() {
    return true;
}

戦闘中に攻撃していれば
__applyAttackSkillEffectAfterCombatNeverthelessDeadForUnit(attackUnit, attackTargetUnit) {}

「歌う」「踊る」使用時
__applyRefresh(skillOwnerUnit, targetUnit) {}

移動系補助(体当たり、引き戻し、回り込み等)を使用した時、または自分に使用された時
__applyMovementAssistSkill() {}

自分を除く自軍内の移動タイプの種類数によって異なる効果を発動
enumerateUnitsInTheSameGroupOnMap()
let sameMoveTypeCount = 0;
for (let otherUnit of this.enumerateUnitsInTheSameGroupOnMap(unit)) {
    if (otherUnit.moveType == unit.moveType) { ++sameMoveTypeCount; }
}

上記の効果は、各自軍ターン、各敵軍ターンそれぞれについて、このスキル所持者の最初の戦闘のみ
targetUnit.isOneTimeActionActivatedForWeapon

再移動(N)
__canActivateCanto(unit) {}
unit.calcMoveCountForCanto() {}

移動可能[ワープ]
const TeleportationSkillDictに登録
Main.js
*__enumerateTeleportTiles(unit) {
    // 周囲2マス以内の味方の、周囲2マス以内に移動可能
    for (let ally of this.enumerateUnitsInTheSameGroupWithinSpecifiedSpaces(unit, 2)) {
        for (let tile of this.__enumeratePlacableTilesWithinSpecifiedSpaces(ally.placedTile, unit, 2)) {
            yield tile;
        }
    }
}


天駆の道
function hasPathfinderEffect(skillId) {}

神竜の花を自身に使用した回数がN回
targetUnit.dragonflower === N

【XXX】の状態を付与(ステータス追加)
Unit.js
const StatusEffectType = {
    XXX: YYY, // XXX
}
function statusEffectTypeToIconFilePath(value) {
    case StatusEffectType.XXX:
    return g_imageRootPath + "XXX.png";
}
/// ステータス効果が不利なステータス効果であるかどうかを判定(不利なステータス異常の場合はNegativeStatusEffectTableに登録すること)
function isNegativeStatusEffect(type) {}

ステータス付与
Main.js
unit.reserveToAddStatusEffect(StatusEffectType.XXX);

比翼・双界英雄
Unit.js
const Hero = {
    XXX: YYY,
}
Main.js
    __activateDuoOrHarmonizedSkill(duoUnit) {
        // 同じ出典のキャラクターに付与
        this.__addStatusEffectToSameOriginUnits(duoUnit, StatusEffectType.ZZZ);
    }

ターン毎のインポート、エクスポート設定
fromPerTurnStatusString(value) {}
perTurnStatusToString() {}

新マップ追加
1. MapTypeに新マップを追加
2. mapKindOptionsにオプションを追加
3. AetherRaidMapImageFilesに画像を追加
4. tileTypeToThumbを修正
5. getMapBackgroundImage
6. breakableObjCountOfCurrentMapTypeを修正
7. resetPlacementで特殊なタイルを設定
